# DE-2026-002: N-Dimensional Circulant Tensors

**Version Bump:** major (0.3.0 → 1.0.0)
**Impact Tier:** T3
**Status:** complete

---

## Justification

### Problem Statement

The circulant-rs library currently supports:
- 1D circulant matrices via `Circulant<T>` (O(n log n) multiplication)
- 2D BCCB matrices via `BlockCirculant<T>` (O(n² log n) multiplication)

However, many applications require higher-dimensional circulant operations:
- **3D convolutions:** Medical imaging (CT/MRI), volumetric video processing
- **4D+ tensor operations:** Hyperspectral imaging, neural network convolutions
- **Physics simulations:** Multi-dimensional lattice systems, quantum walks on hypercubic graphs
- **Signal processing:** Multi-channel, multi-dimensional filtering

### Strategic Value

1. **Unified API:** Single `CirculantTensor<T, D>` type for any dimension (1D, 2D, 3D, N-D)
2. **Performance:** O(N log N) complexity via separable N-D FFT (vs O(N²) naive)
3. **Memory efficiency:** Store only generator tensor, not full N^D matrix
4. **Mathematical completeness:** Natural extension of circulant theory to tensor algebra
5. **Competitive positioning:** Few libraries offer generic N-D circulant operations

### Use Cases

| Dimension | Application | Example |
|-----------|-------------|---------|
| 3D | Medical imaging | 3D Gaussian blur on CT volumes |
| 3D | Scientific computing | 3D Poisson solver on periodic domain |
| 4D | Video processing | Spatiotemporal filtering (x, y, z, t) |
| N-D | Machine learning | N-D convolution kernels |

---

## Avoidance Analysis (T3)

| Alternative | Rejected Because |
|-------------|------------------|
| Repeated 2D operations | Loses tensor structure; inefficient reshaping; complex API |
| External library (fftw-nD, ndrustfft) | Adds heavy dependency; loses circulant-specific optimizations |
| Fixed 3D/4D types | Not extensible; duplicates code; violates DRY |
| Dynamic dimension only | Loses compile-time guarantees; performance overhead |
| Leave to user | Complex implementation; defeats library purpose |

### Recommended Approach

**Const-generic N-D tensor** with compile-time dimension validation:
```rust
pub struct CirculantTensor<T: Scalar + FftNum, const D: usize> {
    generator: ArrayD<Complex<T>>,      // Shape [n₁, n₂, ..., n_D]
    cached_spectrum: Option<ArrayD<Complex<T>>>,
    fft_backends: Vec<Arc<RustFftBackend<T>>>,  // One per dimension
    shape: [usize; D],                  // Compile-time dimension count
}
```

---

## Scope

### Files Created

- [x] `src/core/tensor.rs` - `CirculantTensor<T, D>` implementation (~950 lines)
- [x] `tests/tensor_property_tests.rs` - Property-based tests
- [x] `benches/tensor_benchmark.rs` - Performance benchmarks
- [x] `examples/tensor_3d.rs` - 3D usage example
- [x] `examples/tensor_nd.rs` - Generic N-D example
- [x] `docs/events/DE-2026-002.md` - This document

### Files Modified

- [x] `src/core/mod.rs` - Export new tensor module
- [x] `src/traits/ops.rs` - Add `TensorOps<T, D>` trait
- [x] `src/lib.rs` - Re-export tensor types
- [x] `src/error.rs` - Add tensor error variants
- [x] `src/prelude.rs` - Add tensor re-exports
- [x] `docs/math.md` - Add N-D circulant theory section
- [x] `docs/USER_GUIDE.md` - Add tensor tutorials
- [x] `docs/API_TREE.md` - Add tensor API documentation
- [x] `docs/CHANGELOG.md` - Version 1.0.0 entry
- [x] `README.md` - Update version, description, add tensor examples
- [x] `Cargo.toml` - Bump to 1.0.0

---

## Mathematical Specification

### N-D Circulant Tensor Definition

An N-D circulant tensor C of shape [n₁, n₂, ..., n_D] is defined by a generator tensor G of the same shape, where:

```
C[i₁, i₂, ..., i_D, j₁, j₂, ..., j_D] = G[(i₁-j₁) mod n₁, (i₂-j₂) mod n₂, ..., (i_D-j_D) mod n_D]
```

### N-D FFT Diagonalization

**Theorem:** Any N-D circulant tensor is diagonalized by the N-D DFT:
```
C = F_D⁻¹ Λ F_D
```
where:
- F_D = F₁ ⊗ F₂ ⊗ ... ⊗ F_D (Kronecker product of 1D DFT matrices)
- Λ = diag(FFT_ND(G)) (eigenvalues from N-D FFT of generator)

### Multiplication Algorithm (Tensor-Vector)

```
Input: Generator G[n₁,...,n_D], vector x of length ∏nᵢ
Output: y = C·x

Algorithm:
  1. Reshape x to tensor X[n₁,...,n_D]
  2. λ ← FFT_ND(G)           // Separable: FFT along each axis
  3. X̂ ← FFT_ND(X)
  4. Ŷ ← λ ⊙ X̂              // Element-wise product
  5. Y ← IFFT_ND(Ŷ)
  6. Flatten Y to vector y

Complexity: O(N log N) where N = ∏nᵢ
```

### Separable N-D FFT

N-D FFT is computed by applying 1D FFT along each axis sequentially:

```
FFT_ND(X) = FFT_axis(D-1, FFT_axis(D-2, ... FFT_axis(0, X)))
```

**Complexity:** O(N log N) where N = total elements

### Properties to Verify

| Property | Mathematical Statement | Test Strategy |
|----------|----------------------|---------------|
| FFT correctness | IFFT(FFT(X)) = X | Round-trip within 1e-10 |
| Eigenvalue count | N-D tensor has ∏nᵢ eigenvalues | Assert count equality |
| Linearity | C(αx + βy) = αC(x) + βC(y) | Property test |
| Commutativity | C₁C₂ = C₂C₁ (same shape) | Property test |
| Identity | I·x = x | Unit generator test |
| Convolution theorem | C·x = IFFT(FFT(G) ⊙ FFT(x)) | Compare vs naive |
| Associativity | (C₁C₂)x = C₁(C₂x) | Property test |
| Separability | FFT_ND = ∏ FFT_1D (sequential) | Multi-axis test |

---

## API Design

### Core Types

```rust
/// N-dimensional circulant tensor with compile-time dimension count
pub struct CirculantTensor<T: Scalar + FftNum, const D: usize> {
    // ...
}

/// Operations trait for N-D circulant tensors
pub trait TensorOps<T: Scalar, const D: usize> {
    fn mul_tensor(&self, x: &ArrayD<Complex<T>>) -> Result<ArrayD<Complex<T>>>;
    fn mul_vec(&self, x: &[Complex<T>]) -> Result<Vec<Complex<T>>>;
    fn eigenvalues_nd(&self) -> ArrayD<Complex<T>>;
    fn shape(&self) -> [usize; D];
    fn total_size(&self) -> usize;
}
```

### Constructor API

```rust
impl<T: Scalar + FftNum, const D: usize> CirculantTensor<T, D> {
    /// Create from generator tensor
    pub fn new(generator: ArrayD<Complex<T>>) -> Result<Self>;

    /// Create from real-valued generator
    pub fn from_real(generator: ArrayD<T>) -> Result<Self>;

    /// Precompute spectrum for repeated operations
    pub fn precompute(&mut self);

    /// Check if spectrum is cached
    pub fn is_precomputed(&self) -> bool;
}
```

### Type Aliases

```rust
// Type aliases for common dimensions
pub type Circulant1D<T> = CirculantTensor<T, 1>;
pub type Circulant2D<T> = CirculantTensor<T, 2>;
pub type Circulant3D<T> = CirculantTensor<T, 3>;
pub type Circulant4D<T> = CirculantTensor<T, 4>;
```

---

## Migration Path

### Deprecation Plan

```rust
#[deprecated(since = "1.0.0", note = "Use CirculantTensor<T, 1> instead")]
pub type Circulant<T> = ...;

#[deprecated(since = "1.0.0", note = "Use CirculantTensor<T, 2> instead")]
pub type BlockCirculant<T> = ...;
```

### Breaking Changes

| Old API | New API | Migration |
|---------|---------|-----------|
| `Circulant::new(vec)` | `CirculantTensor::<_, 1>::new(array1d)` | Wrap in ArrayD |
| `BlockCirculant::from_kernel()` | `CirculantTensor::<_, 2>::from_kernel()` | Same pattern |
| `circulant.mul_vec(&slice)` | `tensor.mul_vec(&slice)` | Compatible |
| `block.mul_array(&array2d)` | `tensor.mul_tensor(&arrayd)` | Use ArrayD |

---

## Verification Gates

- [ ] `@math_verified: true` on all test files
- [ ] `cargo test --all-features` passes
- [ ] `cargo clippy --all-features -- -D warnings` passes
- [ ] `rg "\.unwrap\(\)" src/` returns 0
- [ ] Version bump to 1.0.0 matches T3 tier
- [ ] All property tests pass (1000+ cases each)
- [ ] Benchmark shows O(N log N) scaling
- [ ] Memory usage is O(N) for generator storage

---

## Measures of Success

### Functional Acceptance Criteria

| Criterion | Metric | Target |
|-----------|--------|--------|
| Dimensions supported | D parameter | Any D ≥ 1 |
| FFT correctness | Round-trip error | < 1e-10 |
| Naive comparison | Max element error | < 1e-8 |
| Property tests | Pass rate | 100% (1000 cases) |
| Linearity | Violation rate | 0% |
| API completeness | Methods implemented | 100% per spec |

### Performance Acceptance Criteria

| Criterion | Metric | Target |
|-----------|--------|--------|
| Complexity | Time vs N | O(N log N) verified |
| 3D 64³ multiply | Throughput | > 100 ops/sec |
| 3D 128³ multiply | Throughput | > 10 ops/sec |
| Memory overhead | vs generator size | < 3× |
| Precompute speedup | Ratio | > 2× for repeated ops |
| vs naive 3D (32³) | Speedup | > 100× |

### Quality Acceptance Criteria

| Criterion | Metric | Target |
|-----------|--------|--------|
| Test coverage | Line coverage | > 90% for tensor module |
| Documentation | All public items | 100% documented |
| Examples | Working examples | ≥ 2 |
| No unsafe | Unsafe blocks | 0 |
| No unwrap in src/ | Occurrences | 0 |
| Clippy warnings | Count | 0 |
